// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: worktree.sql

package model

import (
	"context"
	"time"
)

const worktreeCreate = `-- name: WorktreeCreate :one
INSERT INTO worktrees (
  id,
  created_at,
  updated_at,
  project_id,
  branch_name,
  path,
  is_main,
  is_bare,
  head_commit,
  status_ahead,
  status_behind,
  status_modified,
  status_staged,
  status_untracked,
  status_conflicts,
  status_updated_at
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8,
  ?9,
  ?10,
  ?11,
  ?12,
  ?13,
  ?14,
  ?15,
  ?16
) RETURNING
  id,
  created_at,
  updated_at,
  deleted_at,
  project_id,
  branch_name,
  path,
  is_main,
  is_bare,
  head_commit,
  status_ahead,
  status_behind,
  status_modified,
  status_staged,
  status_untracked,
  status_conflicts,
  status_updated_at
`

type WorktreeCreateParams struct {
	Id              string     `db:"id" json:"id"`
	CreatedAt       time.Time  `db:"created_at" json:"createdAt"`
	UpdatedAt       time.Time  `db:"updated_at" json:"updatedAt"`
	ProjectId       string     `db:"project_id" json:"projectId"`
	BranchName      string     `db:"branch_name" json:"branchName"`
	Path            string     `db:"path" json:"path"`
	IsMain          bool       `db:"is_main" json:"isMain"`
	IsBare          bool       `db:"is_bare" json:"isBare"`
	HeadCommit      *string    `db:"head_commit" json:"headCommit"`
	StatusAhead     int64      `db:"status_ahead" json:"statusAhead"`
	StatusBehind    int64      `db:"status_behind" json:"statusBehind"`
	StatusModified  int64      `db:"status_modified" json:"statusModified"`
	StatusStaged    int64      `db:"status_staged" json:"statusStaged"`
	StatusUntracked int64      `db:"status_untracked" json:"statusUntracked"`
	StatusConflicts int64      `db:"status_conflicts" json:"statusConflicts"`
	StatusUpdatedAt *time.Time `db:"status_updated_at" json:"statusUpdatedAt"`
}

func (q *Queries) WorktreeCreate(ctx context.Context, arg *WorktreeCreateParams) (*Worktree, error) {
	row := q.queryRow(ctx, q.worktreeCreateStmt, worktreeCreate,
		arg.Id,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProjectId,
		arg.BranchName,
		arg.Path,
		arg.IsMain,
		arg.IsBare,
		arg.HeadCommit,
		arg.StatusAhead,
		arg.StatusBehind,
		arg.StatusModified,
		arg.StatusStaged,
		arg.StatusUntracked,
		arg.StatusConflicts,
		arg.StatusUpdatedAt,
	)
	var i Worktree
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectId,
		&i.BranchName,
		&i.Path,
		&i.IsMain,
		&i.IsBare,
		&i.HeadCommit,
		&i.StatusAhead,
		&i.StatusBehind,
		&i.StatusModified,
		&i.StatusStaged,
		&i.StatusUntracked,
		&i.StatusConflicts,
		&i.StatusUpdatedAt,
	)
	return &i, err
}

const worktreeGetByID = `-- name: WorktreeGetByID :one
SELECT
  id,
  created_at,
  updated_at,
  deleted_at,
  project_id,
  branch_name,
  path,
  is_main,
  is_bare,
  head_commit,
  status_ahead,
  status_behind,
  status_modified,
  status_staged,
  status_untracked,
  status_conflicts,
  status_updated_at
FROM worktrees
WHERE id = ?1
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) WorktreeGetByID(ctx context.Context, id string) (*Worktree, error) {
	row := q.queryRow(ctx, q.worktreeGetByIDStmt, worktreeGetByID, id)
	var i Worktree
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectId,
		&i.BranchName,
		&i.Path,
		&i.IsMain,
		&i.IsBare,
		&i.HeadCommit,
		&i.StatusAhead,
		&i.StatusBehind,
		&i.StatusModified,
		&i.StatusStaged,
		&i.StatusUntracked,
		&i.StatusConflicts,
		&i.StatusUpdatedAt,
	)
	return &i, err
}

const worktreeListByProject = `-- name: WorktreeListByProject :many
SELECT
  id,
  created_at,
  updated_at,
  deleted_at,
  project_id,
  branch_name,
  path,
  is_main,
  is_bare,
  head_commit,
  status_ahead,
  status_behind,
  status_modified,
  status_staged,
  status_untracked,
  status_conflicts,
  status_updated_at
FROM worktrees
WHERE project_id = ?1
  AND deleted_at IS NULL
ORDER BY is_main DESC, created_at ASC
`

func (q *Queries) WorktreeListByProject(ctx context.Context, projectID string) ([]*Worktree, error) {
	rows, err := q.query(ctx, q.worktreeListByProjectStmt, worktreeListByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Worktree
	for rows.Next() {
		var i Worktree
		if err := rows.Scan(
			&i.Id,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectId,
			&i.BranchName,
			&i.Path,
			&i.IsMain,
			&i.IsBare,
			&i.HeadCommit,
			&i.StatusAhead,
			&i.StatusBehind,
			&i.StatusModified,
			&i.StatusStaged,
			&i.StatusUntracked,
			&i.StatusConflicts,
			&i.StatusUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const worktreeSoftDelete = `-- name: WorktreeSoftDelete :execrows
UPDATE worktrees
SET
  deleted_at = ?1,
  updated_at = ?2
WHERE id = ?3
  AND deleted_at IS NULL
`

type WorktreeSoftDeleteParams struct {
	DeletedAt *time.Time `db:"deleted_at" json:"deletedAt"`
	UpdatedAt time.Time  `db:"updated_at" json:"updatedAt"`
	Id        string     `db:"id" json:"id"`
}

func (q *Queries) WorktreeSoftDelete(ctx context.Context, arg *WorktreeSoftDeleteParams) (int64, error) {
	result, err := q.exec(ctx, q.worktreeSoftDeleteStmt, worktreeSoftDelete, arg.DeletedAt, arg.UpdatedAt, arg.Id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const worktreeUpdateMetadata = `-- name: WorktreeUpdateMetadata :exec
UPDATE worktrees
SET
  updated_at = ?1,
  branch_name = ?2,
  head_commit = ?3,
  is_main = ?4,
  is_bare = ?5
WHERE id = ?6
  AND deleted_at IS NULL
`

type WorktreeUpdateMetadataParams struct {
	UpdatedAt  time.Time `db:"updated_at" json:"updatedAt"`
	BranchName string    `db:"branch_name" json:"branchName"`
	HeadCommit *string   `db:"head_commit" json:"headCommit"`
	IsMain     bool      `db:"is_main" json:"isMain"`
	IsBare     bool      `db:"is_bare" json:"isBare"`
	Id         string    `db:"id" json:"id"`
}

func (q *Queries) WorktreeUpdateMetadata(ctx context.Context, arg *WorktreeUpdateMetadataParams) error {
	_, err := q.exec(ctx, q.worktreeUpdateMetadataStmt, worktreeUpdateMetadata,
		arg.UpdatedAt,
		arg.BranchName,
		arg.HeadCommit,
		arg.IsMain,
		arg.IsBare,
		arg.Id,
	)
	return err
}

const worktreeUpdateStatus = `-- name: WorktreeUpdateStatus :one
UPDATE worktrees
SET
  updated_at = ?1,
  status_ahead = ?2,
  status_behind = ?3,
  status_modified = ?4,
  status_staged = ?5,
  status_untracked = ?6,
  status_conflicts = ?7,
  status_updated_at = ?8,
  head_commit = COALESCE(?9, head_commit)
WHERE id = ?10
  AND deleted_at IS NULL
RETURNING
  id,
  created_at,
  updated_at,
  deleted_at,
  project_id,
  branch_name,
  path,
  is_main,
  is_bare,
  head_commit,
  status_ahead,
  status_behind,
  status_modified,
  status_staged,
  status_untracked,
  status_conflicts,
  status_updated_at
`

type WorktreeUpdateStatusParams struct {
	UpdatedAt       time.Time  `db:"updated_at" json:"updatedAt"`
	StatusAhead     int64      `db:"status_ahead" json:"statusAhead"`
	StatusBehind    int64      `db:"status_behind" json:"statusBehind"`
	StatusModified  int64      `db:"status_modified" json:"statusModified"`
	StatusStaged    int64      `db:"status_staged" json:"statusStaged"`
	StatusUntracked int64      `db:"status_untracked" json:"statusUntracked"`
	StatusConflicts int64      `db:"status_conflicts" json:"statusConflicts"`
	StatusUpdatedAt *time.Time `db:"status_updated_at" json:"statusUpdatedAt"`
	HeadCommit      *string    `db:"head_commit" json:"headCommit"`
	Id              string     `db:"id" json:"id"`
}

func (q *Queries) WorktreeUpdateStatus(ctx context.Context, arg *WorktreeUpdateStatusParams) (*Worktree, error) {
	row := q.queryRow(ctx, q.worktreeUpdateStatusStmt, worktreeUpdateStatus,
		arg.UpdatedAt,
		arg.StatusAhead,
		arg.StatusBehind,
		arg.StatusModified,
		arg.StatusStaged,
		arg.StatusUntracked,
		arg.StatusConflicts,
		arg.StatusUpdatedAt,
		arg.HeadCommit,
		arg.Id,
	)
	var i Worktree
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectId,
		&i.BranchName,
		&i.Path,
		&i.IsMain,
		&i.IsBare,
		&i.HeadCommit,
		&i.StatusAhead,
		&i.StatusBehind,
		&i.StatusModified,
		&i.StatusStaged,
		&i.StatusUntracked,
		&i.StatusConflicts,
		&i.StatusUpdatedAt,
	)
	return &i, err
}
