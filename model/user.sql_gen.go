// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package model

import (
	"context"
	"time"
)

const accessTokenCreate = `-- name: AccessTokenCreate :one
INSERT INTO user_access_tokens (
  id,
  created_at,
  updated_at,
  user_id,
  expired_at
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5
) RETURNING
  id,
  created_at,
  updated_at,
  user_id,
  expired_at
`

type AccessTokenCreateParams struct {
	Id        *string   `db:"id" json:"id"`
	CreatedAt time.Time `db:"created_at" json:"createdAt"`
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	UserId    string    `db:"user_id" json:"userId"`
	ExpiredAt time.Time `db:"expired_at" json:"expiredAt"`
}

type AccessTokenCreateRow struct {
	Id        *string   `db:"id" json:"id"`
	CreatedAt time.Time `db:"created_at" json:"createdAt"`
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	UserId    string    `db:"user_id" json:"userId"`
	ExpiredAt time.Time `db:"expired_at" json:"expiredAt"`
}

func (q *Queries) AccessTokenCreate(ctx context.Context, arg *AccessTokenCreateParams) (*AccessTokenCreateRow, error) {
	row := q.queryRow(ctx, q.accessTokenCreateStmt, accessTokenCreate,
		arg.Id,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UserId,
		arg.ExpiredAt,
	)
	var i AccessTokenCreateRow
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserId,
		&i.ExpiredAt,
	)
	return &i, err
}

const accessTokenDeleteAllByUserId = `-- name: AccessTokenDeleteAllByUserId :exec
DELETE FROM user_access_tokens
WHERE user_id = ?1
`

func (q *Queries) AccessTokenDeleteAllByUserId(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.accessTokenDeleteAllByUserIdStmt, accessTokenDeleteAllByUserId, userID)
	return err
}

const accessTokenGetById = `-- name: AccessTokenGetById :one
SELECT
  id,
  created_at,
  updated_at,
  user_id,
  expired_at
FROM user_access_tokens
WHERE id = ?1
LIMIT 1
`

type AccessTokenGetByIdRow struct {
	Id        *string   `db:"id" json:"id"`
	CreatedAt time.Time `db:"created_at" json:"createdAt"`
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	UserId    string    `db:"user_id" json:"userId"`
	ExpiredAt time.Time `db:"expired_at" json:"expiredAt"`
}

func (q *Queries) AccessTokenGetById(ctx context.Context, id *string) (*AccessTokenGetByIdRow, error) {
	row := q.queryRow(ctx, q.accessTokenGetByIdStmt, accessTokenGetById, id)
	var i AccessTokenGetByIdRow
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserId,
		&i.ExpiredAt,
	)
	return &i, err
}

const accessTokenRefresh = `-- name: AccessTokenRefresh :exec
UPDATE user_access_tokens
SET
  updated_at = ?1,
  expired_at = ?2
WHERE id = ?3
`

type AccessTokenRefreshParams struct {
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	ExpiredAt time.Time `db:"expired_at" json:"expiredAt"`
	Id        *string   `db:"id" json:"id"`
}

func (q *Queries) AccessTokenRefresh(ctx context.Context, arg *AccessTokenRefreshParams) error {
	_, err := q.exec(ctx, q.accessTokenRefreshStmt, accessTokenRefresh, arg.UpdatedAt, arg.ExpiredAt, arg.Id)
	return err
}

const userCreate = `-- name: UserCreate :one
INSERT INTO users (
  id,
  created_at,
  updated_at,
  nickname,
  avatar,
  brief,
  username,
  password,
  salt,
  disabled
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8,
  ?9,
  ?10
) RETURNING
  id,
  created_at,
  updated_at,
  deleted_at,
  nickname,
  avatar,
  brief,
  username,
  password,
  salt,
  disabled
`

type UserCreateParams struct {
	Id        *string   `db:"id" json:"id"`
	CreatedAt time.Time `db:"created_at" json:"createdAt"`
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	Nickname  *string   `db:"nickname" json:"nickname"`
	Avatar    *string   `db:"avatar" json:"avatar"`
	Brief     *string   `db:"brief" json:"brief"`
	Username  string    `db:"username" json:"username"`
	Password  string    `db:"password" json:"password"`
	Salt      string    `db:"salt" json:"salt"`
	Disabled  bool      `db:"disabled" json:"disabled"`
}

func (q *Queries) UserCreate(ctx context.Context, arg *UserCreateParams) (*User, error) {
	row := q.queryRow(ctx, q.userCreateStmt, userCreate,
		arg.Id,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Nickname,
		arg.Avatar,
		arg.Brief,
		arg.Username,
		arg.Password,
		arg.Salt,
		arg.Disabled,
	)
	var i User
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Nickname,
		&i.Avatar,
		&i.Brief,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.Disabled,
	)
	return &i, err
}

const userDelete = `-- name: UserDelete :exec
UPDATE users
SET
  deleted_at = ?1,
  updated_at = ?2
WHERE id = ?3
  AND deleted_at IS NULL
`

type UserDeleteParams struct {
	DeletedAt *time.Time `db:"deleted_at" json:"deletedAt"`
	UpdatedAt time.Time  `db:"updated_at" json:"updatedAt"`
	Id        *string    `db:"id" json:"id"`
}

func (q *Queries) UserDelete(ctx context.Context, arg *UserDeleteParams) error {
	_, err := q.exec(ctx, q.userDeleteStmt, userDelete, arg.DeletedAt, arg.UpdatedAt, arg.Id)
	return err
}

const userDisable = `-- name: UserDisable :exec
UPDATE users
SET
  updated_at = ?1,
  disabled = ?2
WHERE id = ?3
  AND deleted_at IS NULL
`

type UserDisableParams struct {
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	Disabled  bool      `db:"disabled" json:"disabled"`
	Id        *string   `db:"id" json:"id"`
}

func (q *Queries) UserDisable(ctx context.Context, arg *UserDisableParams) error {
	_, err := q.exec(ctx, q.userDisableStmt, userDisable, arg.UpdatedAt, arg.Disabled, arg.Id)
	return err
}

const userGetById = `-- name: UserGetById :one
SELECT id, created_at, updated_at, deleted_at, nickname, avatar, brief, username, password, salt, disabled FROM users
WHERE id = ?1
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) UserGetById(ctx context.Context, id *string) (*User, error) {
	row := q.queryRow(ctx, q.userGetByIdStmt, userGetById, id)
	var i User
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Nickname,
		&i.Avatar,
		&i.Brief,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.Disabled,
	)
	return &i, err
}

const userGetByUsername = `-- name: UserGetByUsername :one
SELECT id, created_at, updated_at, deleted_at, nickname, avatar, brief, username, password, salt, disabled FROM users
WHERE username = ?1
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) UserGetByUsername(ctx context.Context, username string) (*User, error) {
	row := q.queryRow(ctx, q.userGetByUsernameStmt, userGetByUsername, username)
	var i User
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Nickname,
		&i.Avatar,
		&i.Brief,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.Disabled,
	)
	return &i, err
}

const userList = `-- name: UserList :many
SELECT
  id,
  created_at,
  updated_at,
  deleted_at,
  nickname,
  avatar,
  brief,
  username,
  '' AS password,
  '' AS salt,
  disabled
FROM users
WHERE deleted_at IS NULL
  AND (CAST(?1 AS TEXT) = '' OR COALESCE(nickname, '') LIKE CAST(?1 AS TEXT) OR COALESCE(username, '') LIKE CAST(?1 AS TEXT))
  AND (COALESCE(CAST(?2 AS BOOLEAN), 0) = 1 OR disabled = 0)
ORDER BY created_at DESC
LIMIT ?4
OFFSET ?3
`

type UserListParams struct {
	Keyword         string `db:"keyword" json:"keyword"`
	IncludeDisabled bool   `db:"include_disabled" json:"includeDisabled"`
	Offset          int64  `db:"offset" json:"offset"`
	Limit           int64  `db:"limit" json:"limit"`
}

type UserListRow struct {
	Id        *string    `db:"id" json:"id"`
	CreatedAt time.Time  `db:"created_at" json:"createdAt"`
	UpdatedAt time.Time  `db:"updated_at" json:"updatedAt"`
	DeletedAt *time.Time `db:"deleted_at" json:"deletedAt"`
	Nickname  *string    `db:"nickname" json:"nickname"`
	Avatar    *string    `db:"avatar" json:"avatar"`
	Brief     *string    `db:"brief" json:"brief"`
	Username  string     `db:"username" json:"username"`
	Password  string     `db:"password" json:"password"`
	Salt      string     `db:"salt" json:"salt"`
	Disabled  bool       `db:"disabled" json:"disabled"`
}

func (q *Queries) UserList(ctx context.Context, arg *UserListParams) ([]*UserListRow, error) {
	rows, err := q.query(ctx, q.userListStmt, userList,
		arg.Keyword,
		arg.IncludeDisabled,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserListRow
	for rows.Next() {
		var i UserListRow
		if err := rows.Scan(
			&i.Id,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Nickname,
			&i.Avatar,
			&i.Brief,
			&i.Username,
			&i.Password,
			&i.Salt,
			&i.Disabled,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userListCount = `-- name: UserListCount :one
SELECT COUNT(1) AS count
FROM users
WHERE deleted_at IS NULL
  AND (CAST(?1 AS TEXT) = '' OR COALESCE(nickname, '') LIKE CAST(?1 AS TEXT) OR COALESCE(username, '') LIKE CAST(?1 AS TEXT))
  AND (COALESCE(CAST(?2 AS BOOLEAN), 0) = 1 OR disabled = 0)
`

type UserListCountParams struct {
	Keyword         string `db:"keyword" json:"keyword"`
	IncludeDisabled bool   `db:"include_disabled" json:"includeDisabled"`
}

func (q *Queries) UserListCount(ctx context.Context, arg *UserListCountParams) (int64, error) {
	row := q.queryRow(ctx, q.userListCountStmt, userListCount, arg.Keyword, arg.IncludeDisabled)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const userUpdateInfo = `-- name: UserUpdateInfo :one
UPDATE users
SET
  updated_at = ?1,
  nickname = COALESCE(?2, nickname),
  avatar = COALESCE(?3, avatar),
  brief = COALESCE(?4, brief)
WHERE id = ?5
  AND deleted_at IS NULL
RETURNING
  id,
  created_at,
  updated_at,
  deleted_at,
  nickname,
  avatar,
  brief,
  username,
  password,
  salt,
  disabled
`

type UserUpdateInfoParams struct {
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	Nickname  *string   `db:"nickname" json:"nickname"`
	Avatar    *string   `db:"avatar" json:"avatar"`
	Brief     *string   `db:"brief" json:"brief"`
	Id        *string   `db:"id" json:"id"`
}

func (q *Queries) UserUpdateInfo(ctx context.Context, arg *UserUpdateInfoParams) (*User, error) {
	row := q.queryRow(ctx, q.userUpdateInfoStmt, userUpdateInfo,
		arg.UpdatedAt,
		arg.Nickname,
		arg.Avatar,
		arg.Brief,
		arg.Id,
	)
	var i User
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Nickname,
		&i.Avatar,
		&i.Brief,
		&i.Username,
		&i.Password,
		&i.Salt,
		&i.Disabled,
	)
	return &i, err
}

const userUpdatePassword = `-- name: UserUpdatePassword :exec
UPDATE users
SET
  updated_at = ?1,
  password = ?2,
  salt = ?3
WHERE id = ?4
  AND deleted_at IS NULL
`

type UserUpdatePasswordParams struct {
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	Password  string    `db:"password" json:"password"`
	Salt      string    `db:"salt" json:"salt"`
	Id        *string   `db:"id" json:"id"`
}

func (q *Queries) UserUpdatePassword(ctx context.Context, arg *UserUpdatePasswordParams) error {
	_, err := q.exec(ctx, q.userUpdatePasswordStmt, userUpdatePassword,
		arg.UpdatedAt,
		arg.Password,
		arg.Salt,
		arg.Id,
	)
	return err
}
