// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: project.sql

package model

import (
	"context"
	"time"
)

const projectCreate = `-- name: ProjectCreate :one
INSERT INTO projects (
  id,
  created_at,
  updated_at,
  name,
  path,
  description,
  default_branch,
  worktree_base_path,
  remote_url,
  hide_path,
  last_sync_at,
  priority
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  CAST(?7 AS TEXT),
  ?8,
  ?9,
  ?10,
  ?11,
  ?12
) RETURNING id, created_at, updated_at, deleted_at, name, path, description, default_branch, worktree_base_path, remote_url, last_sync_at, hide_path, priority
`

type ProjectCreateParams struct {
	Id               string     `db:"id" json:"id"`
	CreatedAt        time.Time  `db:"created_at" json:"createdAt"`
	UpdatedAt        time.Time  `db:"updated_at" json:"updatedAt"`
	Name             string     `db:"name" json:"name"`
	Path             string     `db:"path" json:"path"`
	Description      *string    `db:"description" json:"description"`
	DefaultBranch    string     `db:"default_branch" json:"defaultBranch"`
	WorktreeBasePath *string    `db:"worktree_base_path" json:"worktreeBasePath"`
	RemoteUrl        *string    `db:"remote_url" json:"remoteUrl"`
	HidePath         bool       `db:"hide_path" json:"hidePath"`
	LastSyncAt       *time.Time `db:"last_sync_at" json:"lastSyncAt"`
	Priority         *int64     `db:"priority" json:"priority"`
}

func (q *Queries) ProjectCreate(ctx context.Context, arg *ProjectCreateParams) (*Project, error) {
	row := q.queryRow(ctx, q.projectCreateStmt, projectCreate,
		arg.Id,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Path,
		arg.Description,
		arg.DefaultBranch,
		arg.WorktreeBasePath,
		arg.RemoteUrl,
		arg.HidePath,
		arg.LastSyncAt,
		arg.Priority,
	)
	var i Project
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Path,
		&i.Description,
		&i.DefaultBranch,
		&i.WorktreeBasePath,
		&i.RemoteUrl,
		&i.LastSyncAt,
		&i.HidePath,
		&i.Priority,
	)
	return &i, err
}

const projectGetByID = `-- name: ProjectGetByID :one
SELECT id, created_at, updated_at, deleted_at, name, path, description, default_branch, worktree_base_path, remote_url, last_sync_at, hide_path, priority FROM projects
WHERE id = ?1
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) ProjectGetByID(ctx context.Context, id string) (*Project, error) {
	row := q.queryRow(ctx, q.projectGetByIDStmt, projectGetByID, id)
	var i Project
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Path,
		&i.Description,
		&i.DefaultBranch,
		&i.WorktreeBasePath,
		&i.RemoteUrl,
		&i.LastSyncAt,
		&i.HidePath,
		&i.Priority,
	)
	return &i, err
}

const projectList = `-- name: ProjectList :many
SELECT id, created_at, updated_at, deleted_at, name, path, description, default_branch, worktree_base_path, remote_url, last_sync_at, hide_path, priority FROM projects
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ProjectList(ctx context.Context) ([]*Project, error) {
	rows, err := q.query(ctx, q.projectListStmt, projectList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.Id,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Path,
			&i.Description,
			&i.DefaultBranch,
			&i.WorktreeBasePath,
			&i.RemoteUrl,
			&i.LastSyncAt,
			&i.HidePath,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectSoftDelete = `-- name: ProjectSoftDelete :execrows
UPDATE projects
SET
  deleted_at = ?1,
  updated_at = ?2
WHERE id = ?3
  AND deleted_at IS NULL
`

type ProjectSoftDeleteParams struct {
	DeletedAt *time.Time `db:"deleted_at" json:"deletedAt"`
	UpdatedAt time.Time  `db:"updated_at" json:"updatedAt"`
	Id        string     `db:"id" json:"id"`
}

func (q *Queries) ProjectSoftDelete(ctx context.Context, arg *ProjectSoftDeleteParams) (int64, error) {
	result, err := q.exec(ctx, q.projectSoftDeleteStmt, projectSoftDelete, arg.DeletedAt, arg.UpdatedAt, arg.Id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const projectUpdate = `-- name: ProjectUpdate :one
UPDATE projects
SET
  updated_at = ?1,
  name = ?2,
  description = ?3,
  hide_path = ?4
WHERE id = ?5
  AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, name, path, description, default_branch, worktree_base_path, remote_url, last_sync_at, hide_path, priority
`

type ProjectUpdateParams struct {
	UpdatedAt   time.Time `db:"updated_at" json:"updatedAt"`
	Name        string    `db:"name" json:"name"`
	Description *string   `db:"description" json:"description"`
	HidePath    bool      `db:"hide_path" json:"hidePath"`
	Id          string    `db:"id" json:"id"`
}

func (q *Queries) ProjectUpdate(ctx context.Context, arg *ProjectUpdateParams) (*Project, error) {
	row := q.queryRow(ctx, q.projectUpdateStmt, projectUpdate,
		arg.UpdatedAt,
		arg.Name,
		arg.Description,
		arg.HidePath,
		arg.Id,
	)
	var i Project
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Path,
		&i.Description,
		&i.DefaultBranch,
		&i.WorktreeBasePath,
		&i.RemoteUrl,
		&i.LastSyncAt,
		&i.HidePath,
		&i.Priority,
	)
	return &i, err
}

const projectUpdatePriority = `-- name: ProjectUpdatePriority :one
UPDATE projects
SET
  updated_at = ?1,
  priority = ?2
WHERE id = ?3
  AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, name, path, description, default_branch, worktree_base_path, remote_url, last_sync_at, hide_path, priority
`

type ProjectUpdatePriorityParams struct {
	UpdatedAt time.Time `db:"updated_at" json:"updatedAt"`
	Priority  *int64    `db:"priority" json:"priority"`
	Id        string    `db:"id" json:"id"`
}

func (q *Queries) ProjectUpdatePriority(ctx context.Context, arg *ProjectUpdatePriorityParams) (*Project, error) {
	row := q.queryRow(ctx, q.projectUpdatePriorityStmt, projectUpdatePriority, arg.UpdatedAt, arg.Priority, arg.Id)
	var i Project
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Path,
		&i.Description,
		&i.DefaultBranch,
		&i.WorktreeBasePath,
		&i.RemoteUrl,
		&i.LastSyncAt,
		&i.HidePath,
		&i.Priority,
	)
	return &i, err
}
